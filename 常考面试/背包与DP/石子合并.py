# 石子合并的最小花费
"""
acwing 282
设有N堆石子排成一排，其编号为1，2，3，…，N。
每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。
每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。
例如有4堆石子分别为 1 3 5 2， 我们可以先合并1、2堆，代价为4，得到4 5 2， 又合并 1，2堆，代价为9，得到9 2 ，再合并得到11，总代价为4+9+11=24；
问题是：找出一种合理的方法，使总的代价最小，输出最小代价。


输入样例：
4
1 3 5 2
输出样例：
22
"""
n = int(input())
stones = list(map(int, input().split()))
s = [0]
for x in stones:
    s.append(s[-1] + x)     # 石子重量之和
f = [[0] * n for _ in range(n)]


for len in range(2, n+1):
    for i in range(n - len + 1):
        j = len + i - 1
        f[i][j] = float('inf')
        for k in range(i, j):
            f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j+1] - s[i])

print(f[0][n-1])